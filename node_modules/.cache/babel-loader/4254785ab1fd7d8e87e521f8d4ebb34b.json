{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\subed\\\\OneDrive\\\\Javascript\\\\01-starting-setup\\\\src\\\\components\\\\UI\\\\Button\\\\Button.js\";\nimport React from \"react\";\nimport classes from \"./Button.module.css\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nconst Button = props => {\n  return /*#__PURE__*/_jsxDEV(\"button\", {\n    type: props.type || \"button\",\n    className: `${classes.button} ${props.className}`,\n    onClick: props.onClick,\n    disabled: props.disabled,\n    children: props.children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 7,\n    columnNumber: 5\n  }, this);\n};\n\n_c = Button;\nexport default _c2 = /*#__PURE__*/React.memo(Button);\n/* Remember we are not passing primitive value to Button. we are passing function when a button is clicked, so basically\n the functions are just objects in js, React.memo compares props.onClick === props.previous.onClick\n It compares two objects, but even if they have the same content, they are never equivalent in js. their comparison\n will result in false. so props technically changes, and button function is re-evaluated.\n\n However, we can make React memo work for prop values that are objects as well. How?\n-> using useCallBack() hook\n\n\n */\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"Button\");\n$RefreshReg$(_c2, \"%default%\");","map":{"version":3,"names":["React","classes","Button","props","type","button","className","onClick","disabled","children","memo"],"sources":["C:/Users/subed/OneDrive/Javascript/01-starting-setup/src/components/UI/Button/Button.js"],"sourcesContent":["import React from \"react\";\n\nimport classes from \"./Button.module.css\";\n\nconst Button = (props) => {\n  return (\n    <button\n      type={props.type || \"button\"}\n      className={`${classes.button} ${props.className}`}\n      onClick={props.onClick}\n      disabled={props.disabled}\n    >\n      {props.children}\n    </button>\n  );\n};\n\nexport default React.memo(Button);\n\n/* Remember we are not passing primitive value to Button. we are passing function when a button is clicked, so basically\n the functions are just objects in js, React.memo compares props.onClick === props.previous.onClick\n It compares two objects, but even if they have the same content, they are never equivalent in js. their comparison\n will result in false. so props technically changes, and button function is re-evaluated.\n\n However, we can make React memo work for prop values that are objects as well. How?\n-> using useCallBack() hook\n\n\n */\n"],"mappings":";AAAA,OAAOA,KAAP,MAAkB,OAAlB;AAEA,OAAOC,OAAP,MAAoB,qBAApB;;;AAEA,MAAMC,MAAM,GAAIC,KAAD,IAAW;EACxB,oBACE;IACE,IAAI,EAAEA,KAAK,CAACC,IAAN,IAAc,QADtB;IAEE,SAAS,EAAG,GAAEH,OAAO,CAACI,MAAO,IAAGF,KAAK,CAACG,SAAU,EAFlD;IAGE,OAAO,EAAEH,KAAK,CAACI,OAHjB;IAIE,QAAQ,EAAEJ,KAAK,CAACK,QAJlB;IAAA,UAMGL,KAAK,CAACM;EANT;IAAA;IAAA;IAAA;EAAA,QADF;AAUD,CAXD;;KAAMP,M;AAaN,kCAAeF,KAAK,CAACU,IAAN,CAAWR,MAAX,CAAf;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module"}